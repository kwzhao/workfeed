Directory structure:
└── ebpf/
    ├── check_bpftool.sh
    ├── load_prog.sh
    ├── Makefile
    ├── loader/
    │   ├── tcp_counter.c
    │   └── tcp_monitor_loader.c
    └── src/
        ├── hello.bpf.c
        ├── tcp_counter.bpf.c
        ├── tcp_counter_no_btf.bpf.c
        ├── tcp_monitor.bpf.c
        └── tcp_monitor.h

================================================
FILE: check_bpftool.sh
================================================
#!/usr/bin/env bash
# check_bpftool.sh - Check bpftool version and warn if too old
set -euo pipefail

REQUIRED_MAJOR=7
REQUIRED_MINOR=1

# Get bpftool version
if ! command -v bpftool &> /dev/null; then
    echo "ERROR: bpftool not found. Please install linux-tools-common or linux-tools-$(uname -r)" >&2
    exit 1
fi

# Parse version (handles v7.2.0, v7.2, v8, etc.)
VERSION_STR=$(bpftool --version | head -1)
VERSION=$(echo "$VERSION_STR" | grep -oE '[0-9]+(\.[0-9]+)?' | head -1 || true)

if [ -z "$VERSION" ]; then
    echo "WARNING: Could not determine bpftool version from: $VERSION_STR" >&2
    exit 0
fi

# Split version safely
read -r MAJOR MINOR _ <<<"$(echo "$VERSION" | tr '.' ' ')"
MINOR=${MINOR:-0}

if (( MAJOR < REQUIRED_MAJOR || (MAJOR == REQUIRED_MAJOR && MINOR < REQUIRED_MINOR) )); then
    echo "========================================="
    echo "WARNING: bpftool version $VERSION is too old"
    echo "========================================="
    echo ""
    echo "You have bpftool v$VERSION, but v${REQUIRED_MAJOR}.${REQUIRED_MINOR}+ is recommended for tracepoint autoattach support."
    echo ""
    echo "Your options:"
    echo "1. Use the libbpf skeleton loader instead (recommended)"
    echo "2. Build newer bpftool from source:"
    echo "   git clone https://github.com/libbpf/bpftool.git"
    echo "   cd bpftool && make && sudo make install"
    echo ""
    echo "For now, you can still compile eBPF programs, but loading tracepoints"
    echo "will require using the skeleton loader (tcp_monitor_loader) instead of"
    echo "direct bpftool commands."
    echo "========================================="
else
    echo "✓ bpftool version ${MAJOR}.${MINOR} OK (>= ${REQUIRED_MAJOR}.${REQUIRED_MINOR})"
fi


================================================
FILE: load_prog.sh
================================================
#!/usr/bin/env bash
# load_prog.sh - Load eBPF program with version-appropriate method
set -euo pipefail

# Check for dry-run flag
DRY_RUN=false
if [[ "${1:-}" == "--dry-run" ]]; then
    DRY_RUN=true
    shift
fi

if (( $# < 2 )); then
    echo "Usage: $0 [--dry-run] <prog.bpf.o> <pin-path> [type]" >&2
    echo "Example: $0 build/hello.bpf.o /sys/fs/bpf/hello" >&2
    echo "         $0 build/xdp.bpf.o /sys/fs/bpf/xdp xdp" >&2
    echo "         $0 --dry-run build/hello.bpf.o /sys/fs/bpf/hello" >&2
    exit 1
fi

PROG_FILE=$1
PIN_PATH=$2
PROG_TYPE=${3:-tracepoint}

# Check if bpftool exists
if ! command -v bpftool &> /dev/null; then
    echo "ERROR: bpftool not found. Install linux-tools-common or linux-tools-$(uname -r)" >&2
    exit 1
fi

# Parse bpftool version (handles v7.2.0, v7.2, v8, etc.)
VERSION_STR=$(bpftool --version | head -1)
read -r MAJOR MINOR _ <<<"$(echo "$VERSION_STR" | grep -oE '[0-9]+(\.[0-9]+)?' | head -1 | tr '.' ' ')"
MINOR=${MINOR:-0}

if (( MAJOR > 7 || (MAJOR == 7 && MINOR >= 1) )); then
    # New bpftool with autoattach support
    echo "Using bpftool ${MAJOR}.${MINOR} with autoattach..."
    CMD="sudo bpftool prog load \"$PROG_FILE\" \"$PIN_PATH\" type \"$PROG_TYPE\" autoattach"
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "DRY RUN: Would execute: $CMD"
    else
        if ! eval "$CMD"; then
            echo "ERROR: Failed to load program" >&2
            exit 2
        fi
        echo "✓ Program loaded and attached successfully"
    fi
else
    # Old bpftool - warn and load without attach
    echo "WARNING: bpftool ${MAJOR}.${MINOR} lacks autoattach for tracepoints"
    echo "Loading program only (not attached)."
    CMD="sudo bpftool prog load \"$PROG_FILE\" \"$PIN_PATH\" type \"$PROG_TYPE\""
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "DRY RUN: Would execute: $CMD"
    else
        if ! eval "$CMD"; then
            echo "ERROR: Failed to load program" >&2
            exit 2
        fi
    fi
    echo ""
    echo "➡  To attach this program, either:"
    echo "   1. Use a libbpf-based loader (see loader/ directory)"
    echo "   2. Upgrade bpftool (v7.1+):"
    echo "      git clone https://github.com/libbpf/bpftool.git"
    echo "      cd bpftool && make && sudo make install"
fi


================================================
FILE: Makefile
================================================
# Makefile for Workfeed eBPF programs

# Compiler settings
CLANG ?= clang
CC ?= gcc
LLVM_STRIP ?= llvm-strip
BPFTOOL ?= bpftool

# Directories
SRC_DIR := src
LOADER_DIR := loader
INCLUDE_DIR := include
BUILD_DIR := build

# Create build directory
$(shell mkdir -p $(BUILD_DIR))

# Flags
CFLAGS := -g -O2 -Wall
BPF_CFLAGS := -target bpf -D__TARGET_ARCH_x86_64 -I$(INCLUDE_DIR)
LOADER_CFLAGS := $(CFLAGS) -I$(INCLUDE_DIR)
LDFLAGS := -lbpf -lelf

# Source files
BPF_SRCS := $(wildcard $(SRC_DIR)/*.bpf.c)
BPF_OBJS := $(patsubst $(SRC_DIR)/%.bpf.c,$(BUILD_DIR)/%.bpf.o,$(BPF_SRCS))
LOADER_SRCS := $(wildcard $(LOADER_DIR)/*.c)
LOADER_BINS := $(patsubst $(LOADER_DIR)/%.c,$(BUILD_DIR)/%,$(LOADER_SRCS))

# Default target
all: check-version $(BPF_OBJS) $(LOADER_BINS)

# Check bpftool version
check-version:
	@./check_bpftool.sh

# Build eBPF programs
$(BUILD_DIR)/%.bpf.o: $(SRC_DIR)/%.bpf.c
	$(CLANG) $(BPF_CFLAGS) -g -c $< -o $@

# Generate skeleton headers
$(BUILD_DIR)/%.skel.h: $(BUILD_DIR)/%.bpf.o
	$(BPFTOOL) gen skeleton $< > $@

# Build user-space loaders
$(BUILD_DIR)/%: $(LOADER_DIR)/%.c $(BUILD_DIR)/%.skel.h
	$(CC) $(LOADER_CFLAGS) -I$(BUILD_DIR) $< -o $@ $(LDFLAGS)

# Clean build artifacts
clean:
	rm -rf $(BUILD_DIR)

# Install (TBD - will add install targets later)
install:
	@echo "Install target not yet implemented"

.PHONY: all clean install


================================================
FILE: loader/tcp_counter.c
================================================
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <stdarg.h>
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include "tcp_counter.skel.h"

static volatile bool running = true;

static int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)
{
    return vfprintf(stderr, format, args);
}

static void sig_handler(int sig)
{
    running = false;
}

int main(int argc, char **argv)
{
    struct tcp_counter_bpf *skel;
    int err;

    /* Set up signal handler */
    signal(SIGINT, sig_handler);
    signal(SIGTERM, sig_handler);

    /* Set libbpf debug output */
    libbpf_set_print(libbpf_print_fn);

    /* Open BPF skeleton */
    skel = tcp_counter_bpf__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\n");
        return 1;
    }

    /* Load BPF object */
    err = tcp_counter_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load BPF object: %d\n", err);
        tcp_counter_bpf__destroy(skel);
        return 1;
    }

    /* Attach tracepoint */
    err = tcp_counter_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach BPF skeleton\n");
        goto cleanup;
    }

    /* Initialize counter to 0 */
    __u32 key = 0;
    __u64 initial = 0;
    bpf_map_update_elem(bpf_map__fd(skel->maps.conn_count), &key, &initial, BPF_ANY);

    printf("Successfully started! Tracking TCP connections...\n");
    printf("Press Ctrl-C to stop.\n\n");

    /* Main loop - print counter every second */
    while (running) {
        __u32 key = 0;
        __u64 count = 0;
        
        err = bpf_map_lookup_elem(bpf_map__fd(skel->maps.conn_count), 
                                  &key, &count);
        if (!err) {
            printf("\rTotal TCP connections established: %llu", count);
            fflush(stdout);
        }
        
        sleep(1);
    }
    printf("\n");

cleanup:
    tcp_counter_bpf__destroy(skel);
    return err < 0 ? 1 : 0;
}


================================================
FILE: loader/tcp_monitor_loader.c
================================================
/*
 * tcp_monitor_loader.c - User-space loader for TCP monitoring eBPF program
 * 
 * Handles:
 * - Loading the eBPF program into kernel
 * - Setting up ring buffers for data collection
 * - Processing flow events from kernel
 * - Forwarding to Workfeed sampling layer
 */

// Placeholder - will be implemented with libbpf loader logic


================================================
FILE: src/hello.bpf.c
================================================
/*
 * hello.bpf.c - Simple eBPF program to verify setup
 *
 * Traces file open syscalls and prints a message to trace_pipe
 */

#include "vmlinux_dev.h"
#include <bpf/bpf_helpers.h>

char LICENSE[] SEC("license") = "GPL";

SEC("tracepoint/syscalls/sys_enter_openat")
int trace_openat(struct trace_event_raw_sys_enter *ctx)
{
    // openat syscall: int openat(int dirfd, const char *pathname, int flags, ...)
    // args[0] = dirfd, args[1] = pathname, args[2] = flags
    pid_t pid = bpf_get_current_pid_tgid() >> 32;
    
    bpf_printk("Hello eBPF! PID %d called openat with dirfd=%ld\n", pid, ctx->args[0]);
    return 0;
}


================================================
FILE: src/tcp_counter.bpf.c
================================================
#include "vmlinux_dev.h"
#include <bpf/bpf_helpers.h>

char LICENSE[] SEC("license") = "GPL";

// Simple counter map - single entry to count TCP connections
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, __u64);
} conn_count SEC(".maps");

// TCP states are already defined in vmlinux.h

SEC("tracepoint/sock/inet_sock_set_state")
int count_tcp_connections(struct trace_event_raw_inet_sock_set_state *ctx)
{
    // Only count transitions TO established state
    if (ctx->newstate == TCP_ESTABLISHED) {
        __u32 key = 0;
        __u64 *count = bpf_map_lookup_elem(&conn_count, &key);
        if (count) {
            __sync_fetch_and_add(count, 1);
        }
    }
    return 0;
}


================================================
FILE: src/tcp_counter_no_btf.bpf.c
================================================
// SPDX-License-Identifier: GPL-2.0
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

#define TCP_ESTABLISHED 1

struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, __u64);
} conn_count SEC(".maps");

// Use raw tracepoint to avoid BTF dependencies
SEC("raw_tracepoint/inet_sock_set_state")
int count_tcp_connections_raw(struct bpf_raw_tracepoint_args *ctx)
{
    // For inet_sock_set_state, args are:
    // arg0: const struct sock *sk
    // arg1: int oldstate  
    // arg2: int newstate
    int newstate = (int)ctx->args[2];
    
    if (newstate == TCP_ESTABLISHED) {
        __u32 key = 0;
        __u64 *value = bpf_map_lookup_elem(&conn_count, &key);
        if (value) {
            __sync_fetch_and_add(value, 1);
        }
    }
    
    return 0;
}

char _license[] SEC("license") = "GPL";


================================================
FILE: src/tcp_monitor.bpf.c
================================================
/*
 * tcp_monitor.bpf.c - eBPF program for TCP flow monitoring
 * 
 * This will be implemented to track TCP socket lifecycle events
 * and capture per-flow statistics for Workfeed.
 */

// Placeholder - will be implemented with actual monitoring logic


================================================
FILE: src/tcp_monitor.h
================================================
/*
 * tcp_monitor.h - Shared structures between eBPF and user-space
 */

#ifndef __TCP_MONITOR_H
#define __TCP_MONITOR_H

/* Flow information structure */
struct flow_info {
    /* 5-tuple */
    __u32 saddr;    /* Source IP */
    __u32 daddr;    /* Dest IP */
    __u16 sport;    /* Source port */
    __u16 dport;    /* Dest port */
    __u8  protocol; /* TCP = 6 */
    
    /* DSCP and timing */
    __u8  dscp;     /* DSCP value */
    __u64 start_time_ns;
    __u64 end_time_ns;
    
    /* Flow size */
    __u64 bytes_sent;
};

#endif /* __TCP_MONITOR_H */

